{uri {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 CodeableConcept
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:coding
   {:type zen/vector,
    :zen/desc "Code defined by a terminology system",
    :every {:confirms #{Coding}}},
   :text
   {:zen/desc "Plain text representation of the concept",
    :confirms #{string},
    :type zen/string}},
  :confirms #{Element}},
 uuid {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 SubstanceAmount
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:amount
   {:zen/desc
    "Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field",
    :confirms #{Quantity string Range}},
   :amountType
   {:zen/desc
    "Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements",
    :confirms #{CodeableConcept}},
   :amountText
   {:zen/desc "A textual comment on a numeric value",
    :confirms #{string},
    :type zen/string},
   :referenceRange
   {:zen/desc "Reference range of possible or expected values",
    :confirms #{Element},
    :keys
    {:lowLimit
     {:zen/desc "Lower limit possible or expected",
      :confirms #{Quantity}},
     :highLimit
     {:zen/desc "Upper limit possible or expected",
      :confirms #{Quantity}}}}},
  :confirms #{BackboneElement}},
 xhtml {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 Quantity
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:value
   {:zen/desc "Numerical value (with implicit precision)",
    :confirms #{decimal}},
   :comparator
   {:zen/desc "< | <= | >= | > - how to understand the value",
    :confirms #{code},
    :valueset {:name fhir.valuesets/quantity-comparator},
    :type zen/string},
   :unit
   {:zen/desc "Unit representation",
    :confirms #{string},
    :type zen/string},
   :system
   {:zen/desc "System that defines coded unit form", :confirms #{uri}},
   :code
   {:zen/desc "Coded form of the unit",
    :confirms #{code},
    :type zen/string}},
  :confirms #{Element}},
 Count
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys {},
  :confirms #{Quantity}},
 boolean
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/boolean},
 Narrative
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:status
   {:zen/desc "generated | extensions | additional | empty",
    :confirms #{code},
    :valueset {:name fhir.valuesets/narrative-status},
    :type zen/string},
   :div {:zen/desc "Limited xhtml content", :confirms #{xhtml}}},
  :confirms #{Element}},
 Population
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:age
   {:zen/desc "The age of the specific population",
    :confirms #{CodeableConcept Range}},
   :gender
   {:zen/desc "The gender of the specific population",
    :confirms #{CodeableConcept}},
   :race
   {:zen/desc "Race of the specific population",
    :confirms #{CodeableConcept}},
   :physiologicalCondition
   {:zen/desc
    "The existing physiological conditions of the specific population to which this applies",
    :confirms #{CodeableConcept}}},
  :confirms #{BackboneElement}},
 Age
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys {},
  :confirms #{Quantity}},
 Reference
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:reference
   {:zen/desc "Literal reference, Relative, internal or absolute URL",
    :confirms #{string},
    :type zen/string},
   :type
   {:zen/desc "Type the reference refers to (e.g. \"Patient\")",
    :confirms #{uri}},
   :identifier
   {:zen/desc "Logical reference, when literal reference is not known",
    :confirms #{Identifier}},
   :display
   {:zen/desc "Text alternative for the resource",
    :confirms #{string},
    :type zen/string}},
  :confirms #{Element}},
 Annotation
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:author
   {:zen/desc "Individual responsible for the annotation",
    :confirms #{Reference string}},
   :time
   {:zen/desc "When the annotation was made",
    :confirms #{dateTime},
    :type zen/datetime},
   :text
   {:zen/desc "The annotation  - text content (as markdown)",
    :confirms #{markdown}}},
  :confirms #{Element}},
 unsignedInt
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 Signature
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:type
   {:type zen/vector,
    :zen/desc
    "Indication of the reason the entity signed the object(s)",
    :every {:confirms #{Coding}}},
   :when
   {:zen/desc "When the signature was created", :confirms #{instant}},
   :who {:zen/desc "Who signed", :confirms #{Reference}},
   :onBehalfOf
   {:zen/desc "The party represented", :confirms #{Reference}},
   :targetFormat
   {:zen/desc "The technical format of the signed resources",
    :confirms #{code},
    :valueset {:name fhir.valuesets/mimetypes},
    :type zen/string},
   :sigFormat
   {:zen/desc "The technical format of the signature",
    :confirms #{code},
    :valueset {:name fhir.valuesets/mimetypes},
    :type zen/string},
   :data
   {:zen/desc
    "The actual signature content (XML DigSig. JWS, picture, etc.)",
    :confirms #{base64Binary}}},
  :confirms #{Element}},
 MoneyQuantity
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys {},
  :confirms #{Quantity}},
 markdown
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 date {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/date},
 BackboneElement
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:modifierExtension
   {:type zen/vector,
    :zen/desc "Extensions that cannot be ignored even if unrecognized",
    :every {:confirms #{Extension}}}},
  :confirms #{Element}},
 Dosage
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:site
   {:zen/desc "Body site to administer to",
    :confirms #{CodeableConcept}},
   :asNeeded
   {:zen/desc "Take \"as needed\" (for x)",
    :confirms #{CodeableConcept boolean}},
   :method
   {:zen/desc "Technique for administering medication",
    :confirms #{CodeableConcept}},
   :patientInstruction
   {:zen/desc "Patient or consumer oriented instructions",
    :confirms #{string},
    :type zen/string},
   :maxDosePerLifetime
   {:zen/desc "Upper limit on medication per lifetime of the patient",
    :confirms #{Quantity}},
   :maxDosePerAdministration
   {:zen/desc "Upper limit on medication per administration",
    :confirms #{Quantity}},
   :route
   {:zen/desc "How drug should enter body",
    :confirms #{CodeableConcept}},
   :timing
   {:zen/desc "When medication should be administered",
    :confirms #{Timing}},
   :additionalInstruction
   {:type zen/vector,
    :zen/desc
    "Supplemental instruction or warnings to the patient - e.g. \"with meals\", \"may cause drowsiness\"",
    :every {:confirms #{CodeableConcept}}},
   :sequence
   {:zen/desc "The order of the dosage instructions",
    :confirms #{integer}},
   :maxDosePerPeriod
   {:zen/desc "Upper limit on medication per unit of time",
    :confirms #{Ratio}},
   :doseAndRate
   {:type zen/vector,
    :zen/desc "Amount of medication administered",
    :every
    {:confirms #{Element},
     :keys
     {:type
      {:zen/desc "The kind of dose or rate specified",
       :confirms #{CodeableConcept}},
      :dose
      {:zen/desc "Amount of medication per dose",
       :confirms #{Quantity Range}},
      :rate
      {:zen/desc "Amount of medication per unit of time",
       :confirms #{Quantity Ratio Range}}}}},
   :text
   {:zen/desc "Free text dosage instructions e.g. SIG",
    :confirms #{string},
    :type zen/string}},
  :confirms #{BackboneElement}},
 RelatedArtifact
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:type
   {:zen/desc
    "documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of",
    :confirms #{code},
    :valueset {:name fhir.valuesets/related-artifact-type},
    :type zen/string},
   :label
   {:zen/desc "Short label", :confirms #{string}, :type zen/string},
   :display
   {:zen/desc "Brief description of the related artifact",
    :confirms #{string},
    :type zen/string},
   :citation
   {:zen/desc "Bibliographic citation for the artifact",
    :confirms #{markdown}},
   :url
   {:zen/desc "Where the artifact can be accessed", :confirms #{url}},
   :document
   {:zen/desc "What document is being referenced",
    :confirms #{Attachment}},
   :resource
   {:zen/desc "What resource is being referenced",
    :confirms #{canonical},
    :type zen/string}},
  :confirms #{Element}},
 ContactDetail
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:name
   {:zen/desc "Name of an individual to contact",
    :confirms #{string},
    :type zen/string},
   :telecom
   {:type zen/vector,
    :zen/desc "Contact details for individual or organization",
    :every {:confirms #{ContactPoint}}}},
  :confirms #{Element}},
 instant
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 SimpleQuantity
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:comparator
   {:type zen/vector, :zen/desc nil, :every {:confirms #{}}}},
  :confirms #{Quantity}},
 ns fhir.datatypes,
 Element
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:id
   {:zen/desc "Unique id for inter-element referencing",
    :confirms #{http://hl7.org/fhirpath/System.String}},
   :extension
   {:type zen/vector,
    :zen/desc "Additional content defined by implementations",
    :every {:confirms #{Extension}}}}},
 UsageContext
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:code
   {:zen/desc "Type of context being specified", :confirms #{Coding}},
   :value
   {:zen/desc "Value that defines the context",
    :confirms #{CodeableConcept Quantity Reference Range}}},
  :confirms #{Element}},
 DataRequirement
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:type
   {:zen/desc "The type of the required data",
    :confirms #{code},
    :valueset {:name fhir.valuesets/all-types},
    :type zen/string},
   :profile
   {:type zen/vector,
    :zen/desc "The profile of the required data",
    :every {:confirms #{canonical}, :type zen/string}},
   :subject
   {:zen/desc
    "E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device",
    :confirms #{CodeableConcept Reference}},
   :mustSupport
   {:type zen/vector,
    :zen/desc
    "Indicates specific structure elements that are referenced by the knowledge module",
    :every {:confirms #{string}, :type zen/string}},
   :codeFilter
   {:type zen/vector,
    :zen/desc "What codes are expected",
    :every
    {:confirms #{Element},
     :keys
     {:path
      {:zen/desc "A code-valued attribute to filter on",
       :confirms #{string},
       :type zen/string},
      :searchParam
      {:zen/desc "A coded (token) parameter to search on",
       :confirms #{string},
       :type zen/string},
      :valueSet
      {:zen/desc "Valueset for the filter",
       :confirms #{canonical},
       :type zen/string},
      :code
      {:type zen/vector,
       :zen/desc "What code is expected",
       :every {:confirms #{Coding}}}}}},
   :dateFilter
   {:type zen/vector,
    :zen/desc "What dates/date ranges are expected",
    :every
    {:confirms #{Element},
     :keys
     {:path
      {:zen/desc "A date-valued attribute to filter on",
       :confirms #{string},
       :type zen/string},
      :searchParam
      {:zen/desc "A date valued parameter to search on",
       :confirms #{string},
       :type zen/string},
      :value
      {:zen/desc
       "The value of the filter, as a Period, DateTime, or Duration value",
       :confirms #{dateTime Period Duration}}}}},
   :limit {:zen/desc "Number of results", :confirms #{positiveInt}},
   :sort
   {:type zen/vector,
    :zen/desc "Order of the results",
    :every
    {:confirms #{Element},
     :keys
     {:path
      {:zen/desc "The name of the attribute to perform the sort",
       :confirms #{string},
       :type zen/string},
      :direction
      {:zen/desc "ascending | descending",
       :confirms #{code},
       :valueset {:name fhir.valuesets/sort-direction},
       :type zen/string}}}}},
  :confirms #{Element}},
 base64Binary
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 time {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 Meta
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:versionId
   {:zen/desc "Version specific identifier",
    :confirms #{id},
    :type zen/string},
   :lastUpdated
   {:zen/desc "When the resource version last changed",
    :confirms #{instant}},
   :source
   {:zen/desc "Identifies where the resource comes from",
    :confirms #{uri}},
   :profile
   {:type zen/vector,
    :zen/desc "Profiles this resource claims to conform to",
    :every {:confirms #{canonical}, :type zen/string}},
   :security
   {:type zen/vector,
    :zen/desc "Security Labels applied to this resource",
    :every {:confirms #{Coding}}},
   :tag
   {:type zen/vector,
    :zen/desc "Tags applied to this resource",
    :every {:confirms #{Coding}}}},
  :confirms #{Element}},
 Distance
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys {},
  :confirms #{Quantity}},
 SampledData
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:origin {:zen/desc "Zero value and units", :confirms #{Quantity}},
   :period
   {:zen/desc "Number of milliseconds between samples",
    :confirms #{decimal}},
   :factor
   {:zen/desc "Multiply data by this before adding to origin",
    :confirms #{decimal}},
   :lowerLimit
   {:zen/desc "Lower limit of detection", :confirms #{decimal}},
   :upperLimit
   {:zen/desc "Upper limit of detection", :confirms #{decimal}},
   :dimensions
   {:zen/desc "Number of sample points at each time point",
    :confirms #{positiveInt}},
   :data
   {:zen/desc "Decimal values with spaces, or \"E\" | \"U\" | \"L\"",
    :confirms #{string},
    :type zen/string}},
  :confirms #{Element}},
 TriggerDefinition
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:type
   {:zen/desc
    "named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended",
    :confirms #{code},
    :valueset {:name fhir.valuesets/trigger-type},
    :type zen/string},
   :name
   {:zen/desc "Name or URI that identifies the event",
    :confirms #{string},
    :type zen/string},
   :timing
   {:zen/desc "Timing of the event",
    :confirms #{Reference date dateTime Timing}},
   :data
   {:type zen/vector,
    :zen/desc "Triggering data of the event (multiple = 'and')",
    :every {:confirms #{DataRequirement}}},
   :condition
   {:zen/desc "Whether the event triggers (boolean expression)",
    :confirms #{Expression}}},
  :confirms #{Element}},
 Identifier
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:use
   {:zen/desc "usual | official | temp | secondary | old (If known)",
    :confirms #{code},
    :valueset {:name fhir.valuesets/identifier-use},
    :type zen/string},
   :type
   {:zen/desc "Description of identifier",
    :confirms #{CodeableConcept}},
   :system
   {:zen/desc "The namespace for the identifier value",
    :confirms #{uri}},
   :value
   {:zen/desc "The value that is unique",
    :confirms #{string},
    :type zen/string},
   :period
   {:zen/desc "Time period when id is/was valid for use",
    :confirms #{Period}},
   :assigner
   {:zen/desc "Organization that issued id (may be just text)",
    :confirms #{Reference}}},
  :confirms #{Element}},
 string
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 Address
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:use
   {:zen/desc
    "home | work | temp | old | billing - purpose of this address",
    :confirms #{code},
    :valueset {:name fhir.valuesets/address-use},
    :type zen/string},
   :city
   {:zen/desc "Name of city, town etc.",
    :confirms #{string},
    :type zen/string},
   :type
   {:zen/desc "postal | physical | both",
    :confirms #{code},
    :valueset {:name fhir.valuesets/address-type},
    :type zen/string},
   :state
   {:zen/desc "Sub-unit of country (abbreviations ok)",
    :confirms #{string},
    :type zen/string},
   :line
   {:type zen/vector,
    :zen/desc "Street name, number, direction & P.O. Box etc.",
    :every {:confirms #{string}, :type zen/string}},
   :postalCode
   {:zen/desc "Postal code for area",
    :confirms #{string},
    :type zen/string},
   :period
   {:zen/desc "Time period when address was/is in use",
    :confirms #{Period}},
   :country
   {:zen/desc "Country (e.g. can be ISO 3166 2 or 3 letter code)",
    :confirms #{string},
    :type zen/string},
   :district
   {:zen/desc "District name (aka county)",
    :confirms #{string},
    :type zen/string},
   :text
   {:zen/desc "Text representation of the address",
    :confirms #{string},
    :type zen/string}},
  :confirms #{Element}},
 Expression
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:description
   {:zen/desc "Natural language description of the condition",
    :confirms #{string},
    :type zen/string},
   :name
   {:zen/desc "Short name assigned to expression for reuse",
    :confirms #{id},
    :type zen/string},
   :language
   {:zen/desc
    "text/cql | text/fhirpath | application/x-fhir-query | etc.",
    :confirms #{code},
    :type zen/string},
   :expression
   {:zen/desc "Expression in specified language",
    :confirms #{string},
    :type zen/string},
   :reference
   {:zen/desc "Where the expression is found", :confirms #{uri}}},
  :confirms #{Element}},
 ProductShelfLife
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:identifier
   {:zen/desc "Unique identifier for the packaged Medicinal Product",
    :confirms #{Identifier}},
   :type
   {:zen/desc
    "This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified",
    :confirms #{CodeableConcept}},
   :period
   {:zen/desc
    "The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used",
    :confirms #{Quantity}},
   :specialPrecautionsForStorage
   {:type zen/vector,
    :zen/desc
    "Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified",
    :every {:confirms #{CodeableConcept}}}},
  :confirms #{BackboneElement}},
 Extension
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:url
   {:zen/desc "identifies the meaning of the extension",
    :confirms #{http://hl7.org/fhirpath/System.String}},
   :value
   {:zen/desc "Value of extension",
    :confirms
    #{uri
      CodeableConcept
      uuid
      Quantity
      Count
      boolean
      Age
      Reference
      Annotation
      unsignedInt
      Signature
      markdown
      date
      Dosage
      RelatedArtifact
      ContactDetail
      instant
      UsageContext
      DataRequirement
      base64Binary
      time
      Meta
      Distance
      SampledData
      TriggerDefinition
      Identifier
      string
      Address
      Expression
      dateTime
      integer
      Ratio
      oid
      Range
      ContactPoint
      id
      Attachment
      Contributor
      Period
      Money
      decimal
      canonical
      url
      code
      positiveInt
      Coding
      ParameterDefinition
      HumanName
      Duration
      Timing}}},
  :confirms #{Element}},
 dateTime
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/datetime},
 integer
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 Ratio
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:numerator {:zen/desc "Numerator value", :confirms #{Quantity}},
   :denominator
   {:zen/desc "Denominator value", :confirms #{Quantity}}},
  :confirms #{Element}},
 oid {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 ElementDefinition
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:constraint
   {:type zen/vector,
    :zen/desc "Condition that must evaluate to true",
    :every
    {:confirms #{Element},
     :keys
     {:key
      {:zen/desc "Target of 'condition' reference above",
       :confirms #{id},
       :type zen/string},
      :requirements
      {:zen/desc "Why this constraint is necessary or appropriate",
       :confirms #{string},
       :type zen/string},
      :severity
      {:zen/desc "error | warning",
       :confirms #{code},
       :valueset {:name fhir.valuesets/constraint-severity},
       :type zen/string},
      :human
      {:zen/desc "Human description of constraint",
       :confirms #{string},
       :type zen/string},
      :expression
      {:zen/desc "FHIRPath expression of constraint",
       :confirms #{string},
       :type zen/string},
      :xpath
      {:zen/desc "XPath expression of constraint",
       :confirms #{string},
       :type zen/string},
      :source
      {:zen/desc "Reference to original source of constraint",
       :confirms #{canonical},
       :type zen/string}}}},
   :path
   {:zen/desc "Path of the element in the hierarchy of elements",
    :confirms #{string},
    :type zen/string},
   :requirements
   {:zen/desc "Why this resource has been created",
    :confirms #{markdown}},
   :min {:zen/desc "Minimum Cardinality", :confirms #{unsignedInt}},
   :definition
   {:zen/desc "Full formal definition as narrative text",
    :confirms #{markdown}},
   :maxValue
   {:zen/desc "Maximum Allowed Value (for some types)",
    :confirms
    #{Quantity
      unsignedInt
      date
      instant
      time
      dateTime
      integer
      decimal
      positiveInt}},
   :isModifier
   {:zen/desc "If this modifies the meaning of other elements",
    :confirms #{boolean},
    :type zen/boolean},
   :short
   {:zen/desc "Concise definition for space-constrained presentation",
    :confirms #{string},
    :type zen/string},
   :mapping
   {:type zen/vector,
    :zen/desc "Map element to another set of definitions",
    :every
    {:confirms #{Element},
     :keys
     {:identity
      {:zen/desc "Reference to mapping declaration",
       :confirms #{id},
       :type zen/string},
      :language
      {:zen/desc "Computable language of mapping",
       :confirms #{code},
       :valueset {:name fhir.valuesets/mimetypes},
       :type zen/string},
      :map
      {:zen/desc "Details of the mapping",
       :confirms #{string},
       :type zen/string},
      :comment
      {:zen/desc "Comments about the mapping or its use",
       :confirms #{string},
       :type zen/string}}}},
   :contentReference
   {:zen/desc "Reference to definition of content for the element",
    :confirms #{uri}},
   :slicing
   {:zen/desc "This element is sliced - slices follow",
    :confirms #{Element},
    :keys
    {:discriminator
     {:type zen/vector,
      :zen/desc
      "Element values that are used to distinguish the slices",
      :every
      {:confirms #{Element},
       :keys
       {:type
        {:zen/desc "value | exists | pattern | type | profile",
         :confirms #{code},
         :valueset {:name fhir.valuesets/discriminator-type},
         :type zen/string},
        :path
        {:zen/desc "Path to element value",
         :confirms #{string},
         :type zen/string}}}},
     :description
     {:zen/desc "Text description of how slicing works (or not)",
      :confirms #{string},
      :type zen/string},
     :ordered
     {:zen/desc "If elements must be in same order as slices",
      :confirms #{boolean},
      :type zen/boolean},
     :rules
     {:zen/desc "closed | open | openAtEnd",
      :confirms #{code},
      :valueset {:name fhir.valuesets/resource-slicing-rules},
      :type zen/string}}},
   :type
   {:type zen/vector,
    :zen/desc "Data type and Profile for this element",
    :every
    {:confirms #{Element},
     :keys
     {:code
      {:zen/desc "Data type or Resource (reference to definition)",
       :confirms #{uri}},
      :profile
      {:type zen/vector,
       :zen/desc
       "Profiles (StructureDefinition or IG) - one must apply",
       :every {:confirms #{canonical}, :type zen/string}},
      :targetProfile
      {:type zen/vector,
       :zen/desc
       "Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply",
       :every {:confirms #{canonical}, :type zen/string}},
      :aggregation
      {:type zen/vector,
       :zen/desc "contained | referenced | bundled - how aggregated",
       :every
       {:confirms #{code},
        :valueset {:name fhir.valuesets/resource-aggregation-mode},
        :type zen/string}},
      :versioning
      {:zen/desc "either | independent | specific",
       :confirms #{code},
       :valueset {:name fhir.valuesets/reference-version-rules},
       :type zen/string}}}},
   :mustSupport
   {:zen/desc "If the element must be supported",
    :confirms #{boolean},
    :type zen/boolean},
   :minValue
   {:zen/desc "Minimum Allowed Value (for some types)",
    :confirms
    #{Quantity
      unsignedInt
      date
      instant
      time
      dateTime
      integer
      decimal
      positiveInt}},
   :sliceName
   {:zen/desc "Name for this particular element (in a set of slices)",
    :confirms #{string},
    :type zen/string},
   :meaningWhenMissing
   {:zen/desc "Implicit meaning when this element is missing",
    :confirms #{markdown}},
   :binding
   {:zen/desc "ValueSet details if this is coded",
    :confirms #{Element},
    :keys
    {:strength
     {:zen/desc "required | extensible | preferred | example",
      :confirms #{code},
      :valueset {:name fhir.valuesets/binding-strength},
      :type zen/string},
     :description
     {:zen/desc "Human explanation of the value set",
      :confirms #{string},
      :type zen/string},
     :valueSet
     {:zen/desc "Source of value set",
      :confirms #{canonical},
      :type zen/string}}},
   :alias
   {:type zen/vector,
    :zen/desc "Other names",
    :every {:confirms #{string}, :type zen/string}},
   :representation
   {:type zen/vector,
    :zen/desc "xmlAttr | xmlText | typeAttr | cdaText | xhtml",
    :every
    {:confirms #{code},
     :valueset {:name fhir.valuesets/property-representation},
     :type zen/string}},
   :max
   {:zen/desc "Maximum Cardinality (a number or *)",
    :confirms #{string},
    :type zen/string},
   :label
   {:zen/desc "Name for element to display with or prompt for element",
    :confirms #{string},
    :type zen/string},
   :condition
   {:type zen/vector,
    :zen/desc "Reference to invariant about presence",
    :every {:confirms #{id}, :type zen/string}},
   :comment
   {:zen/desc "Comments about the use of this element",
    :confirms #{markdown}},
   :code
   {:type zen/vector,
    :zen/desc "Corresponding codes in terminologies",
    :every {:confirms #{Coding}}},
   :maxLength
   {:zen/desc "Max length for strings", :confirms #{integer}},
   :sliceIsConstraining
   {:zen/desc
    "If this slice definition constrains an inherited slice definition (or not)",
    :confirms #{boolean},
    :type zen/boolean},
   :example
   {:type zen/vector,
    :zen/desc "Example value (as defined for type)",
    :every
    {:confirms #{Element},
     :keys
     {:label
      {:zen/desc "Describes the purpose of this example",
       :confirms #{string},
       :type zen/string},
      :value
      {:zen/desc "Value of Example (one of allowed types)",
       :confirms
       #{uri
         CodeableConcept
         uuid
         Quantity
         Count
         boolean
         Age
         Reference
         Annotation
         unsignedInt
         Signature
         markdown
         date
         Dosage
         RelatedArtifact
         ContactDetail
         instant
         UsageContext
         DataRequirement
         base64Binary
         time
         Meta
         Distance
         SampledData
         TriggerDefinition
         Identifier
         string
         Address
         Expression
         dateTime
         integer
         Ratio
         oid
         Range
         ContactPoint
         id
         Attachment
         Contributor
         Period
         Money
         decimal
         canonical
         url
         code
         positiveInt
         Coding
         ParameterDefinition
         HumanName
         Duration
         Timing}}}}},
   :orderMeaning
   {:zen/desc "What the order of the elements means",
    :confirms #{string},
    :type zen/string},
   :defaultValue
   {:zen/desc "Specified value if missing from instance",
    :confirms
    #{uri
      CodeableConcept
      uuid
      Quantity
      Count
      boolean
      Age
      Reference
      Annotation
      unsignedInt
      Signature
      markdown
      date
      Dosage
      RelatedArtifact
      ContactDetail
      instant
      UsageContext
      DataRequirement
      base64Binary
      time
      Meta
      Distance
      SampledData
      TriggerDefinition
      Identifier
      string
      Address
      Expression
      dateTime
      integer
      Ratio
      oid
      Range
      ContactPoint
      id
      Attachment
      Contributor
      Period
      Money
      decimal
      canonical
      url
      code
      positiveInt
      Coding
      ParameterDefinition
      HumanName
      Duration
      Timing}},
   :fixed
   {:zen/desc "Value must be exactly this",
    :confirms
    #{uri
      CodeableConcept
      uuid
      Quantity
      Count
      boolean
      Age
      Reference
      Annotation
      unsignedInt
      Signature
      markdown
      date
      Dosage
      RelatedArtifact
      ContactDetail
      instant
      UsageContext
      DataRequirement
      base64Binary
      time
      Meta
      Distance
      SampledData
      TriggerDefinition
      Identifier
      string
      Address
      Expression
      dateTime
      integer
      Ratio
      oid
      Range
      ContactPoint
      id
      Attachment
      Contributor
      Period
      Money
      decimal
      canonical
      url
      code
      positiveInt
      Coding
      ParameterDefinition
      HumanName
      Duration
      Timing}},
   :base
   {:zen/desc "Base definition information for tools",
    :confirms #{Element},
    :keys
    {:path
     {:zen/desc "Path that identifies the base element",
      :confirms #{string},
      :type zen/string},
     :min
     {:zen/desc "Min cardinality of the base element",
      :confirms #{unsignedInt}},
     :max
     {:zen/desc "Max cardinality of the base element",
      :confirms #{string},
      :type zen/string}}},
   :isModifierReason
   {:zen/desc "Reason that this element is marked as a modifier",
    :confirms #{string},
    :type zen/string},
   :isSummary
   {:zen/desc "Include when _summary = true?",
    :confirms #{boolean},
    :type zen/boolean},
   :pattern
   {:zen/desc "Value must have at least these property values",
    :confirms
    #{uri
      CodeableConcept
      uuid
      Quantity
      Count
      boolean
      Age
      Reference
      Annotation
      unsignedInt
      Signature
      markdown
      date
      Dosage
      RelatedArtifact
      ContactDetail
      instant
      UsageContext
      DataRequirement
      base64Binary
      time
      Meta
      Distance
      SampledData
      TriggerDefinition
      Identifier
      string
      Address
      Expression
      dateTime
      integer
      Ratio
      oid
      Range
      ContactPoint
      id
      Attachment
      Contributor
      Period
      Money
      decimal
      canonical
      url
      code
      positiveInt
      Coding
      ParameterDefinition
      HumanName
      Duration
      Timing}}},
  :confirms #{BackboneElement}},
 Range
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:low {:zen/desc "Low limit", :confirms #{Quantity}},
   :high {:zen/desc "High limit", :confirms #{Quantity}}},
  :confirms #{Element}},
 ContactPoint
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:system
   {:zen/desc "phone | fax | email | pager | url | sms | other",
    :confirms #{code},
    :valueset {:name fhir.valuesets/contact-point-system},
    :type zen/string},
   :value
   {:zen/desc "The actual contact point details",
    :confirms #{string},
    :type zen/string},
   :use
   {:zen/desc
    "home | work | temp | old | mobile - purpose of this contact point",
    :confirms #{code},
    :valueset {:name fhir.valuesets/contact-point-use},
    :type zen/string},
   :rank
   {:zen/desc "Specify preferred order of use (1 = highest)",
    :confirms #{positiveInt}},
   :period
   {:zen/desc "Time period when the contact point was/is in use",
    :confirms #{Period}}},
  :confirms #{Element}},
 id {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 Attachment
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:contentType
   {:zen/desc "Mime type of the content, with charset etc.",
    :confirms #{code},
    :valueset {:name fhir.valuesets/mimetypes},
    :type zen/string},
   :language
   {:zen/desc "Human language of the content (BCP-47)",
    :confirms #{code},
    :type zen/string},
   :data
   {:zen/desc "Data inline, base64ed", :confirms #{base64Binary}},
   :url
   {:zen/desc "Uri where the data can be found", :confirms #{url}},
   :size
   {:zen/desc "Number of bytes of content (if url provided)",
    :confirms #{unsignedInt}},
   :hash
   {:zen/desc "Hash of the data (sha-1, base64ed)",
    :confirms #{base64Binary}},
   :title
   {:zen/desc "Label to display in place of the data",
    :confirms #{string},
    :type zen/string},
   :creation
   {:zen/desc "Date attachment was first created",
    :confirms #{dateTime},
    :type zen/datetime}},
  :confirms #{Element}},
 Contributor
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:type
   {:zen/desc "author | editor | reviewer | endorser",
    :confirms #{code},
    :valueset {:name fhir.valuesets/contributor-type},
    :type zen/string},
   :name
   {:zen/desc "Who contributed the content",
    :confirms #{string},
    :type zen/string},
   :contact
   {:type zen/vector,
    :zen/desc "Contact details of the contributor",
    :every {:confirms #{ContactDetail}}}},
  :confirms #{Element}},
 Period
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:start
   {:zen/desc "Starting time with inclusive boundary",
    :confirms #{dateTime},
    :type zen/datetime},
   :end
   {:zen/desc "End time with inclusive boundary, if not ongoing",
    :confirms #{dateTime},
    :type zen/datetime}},
  :confirms #{Element}},
 Money
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:value
   {:zen/desc "Numerical value (with implicit precision)",
    :confirms #{decimal}},
   :currency
   {:zen/desc "ISO 4217 Currency Code",
    :confirms #{code},
    :valueset {:name fhir.valuesets/currencies},
    :type zen/string}},
  :confirms #{Element}},
 decimal
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 canonical
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 MarketingStatus
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:country
   {:zen/desc
    "The country in which the marketing authorisation has been granted shall be specified It should be specified using the ISO 3166 ‑ 1 alpha-2 code elements",
    :confirms #{CodeableConcept}},
   :jurisdiction
   {:zen/desc
    "Where a Medicines Regulatory Agency has granted a marketing authorisation for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified",
    :confirms #{CodeableConcept}},
   :status
   {:zen/desc
    "This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples",
    :confirms #{CodeableConcept}},
   :dateRange
   {:zen/desc
    "The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE “Placed on the market” refers to the release of the Medicinal Product into the distribution chain",
    :confirms #{Period}},
   :restoreDate
   {:zen/desc
    "The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE “Placed on the market” refers to the release of the Medicinal Product into the distribution chain",
    :confirms #{dateTime},
    :type zen/datetime}},
  :confirms #{BackboneElement}},
 url {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 code {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 positiveInt
 {:zen/tags #{fhir/primitive-type zen/schema}, :type zen/string},
 ProdCharacteristic
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:imprint
   {:type zen/vector,
    :zen/desc "Where applicable, the imprint can be specified as text",
    :every {:confirms #{string}, :type zen/string}},
   :color
   {:type zen/vector,
    :zen/desc
    "Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used",
    :every {:confirms #{string}, :type zen/string}},
   :width
   {:zen/desc
    "Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used",
    :confirms #{Quantity}},
   :nominalVolume
   {:zen/desc
    "Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used",
    :confirms #{Quantity}},
   :weight
   {:zen/desc
    "Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used",
    :confirms #{Quantity}},
   :shape
   {:zen/desc
    "Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used",
    :confirms #{string},
    :type zen/string},
   :scoring
   {:zen/desc
    "Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used",
    :confirms #{CodeableConcept}},
   :image
   {:type zen/vector,
    :zen/desc
    "Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations",
    :every {:confirms #{Attachment}}},
   :depth
   {:zen/desc
    "Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used",
    :confirms #{Quantity}},
   :externalDiameter
   {:zen/desc
    "Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used",
    :confirms #{Quantity}},
   :height
   {:zen/desc
    "Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used",
    :confirms #{Quantity}}},
  :confirms #{BackboneElement}},
 Coding
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:system
   {:zen/desc "Identity of the terminology system", :confirms #{uri}},
   :version
   {:zen/desc "Version of the system - if relevant",
    :confirms #{string},
    :type zen/string},
   :code
   {:zen/desc "Symbol in syntax defined by the system",
    :confirms #{code},
    :type zen/string},
   :display
   {:zen/desc "Representation defined by the system",
    :confirms #{string},
    :type zen/string},
   :userSelected
   {:zen/desc "If this coding was chosen directly by the user",
    :confirms #{boolean},
    :type zen/boolean}},
  :confirms #{Element}},
 ParameterDefinition
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:name
   {:zen/desc "Name used to access the parameter value",
    :confirms #{code},
    :type zen/string},
   :use
   {:zen/desc "in | out",
    :confirms #{code},
    :valueset {:name fhir.valuesets/operation-parameter-use},
    :type zen/string},
   :min {:zen/desc "Minimum cardinality", :confirms #{integer}},
   :max
   {:zen/desc "Maximum cardinality (a number of *)",
    :confirms #{string},
    :type zen/string},
   :documentation
   {:zen/desc "A brief description of the parameter",
    :confirms #{string},
    :type zen/string},
   :type
   {:zen/desc "What type of value",
    :confirms #{code},
    :valueset {:name fhir.valuesets/all-types},
    :type zen/string},
   :profile
   {:zen/desc "What profile the value is expected to be",
    :confirms #{canonical},
    :type zen/string}},
  :confirms #{Element}},
 HumanName
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:use
   {:zen/desc
    "usual | official | temp | nickname | anonymous | old | maiden",
    :confirms #{code},
    :valueset {:name fhir.valuesets/name-use},
    :type zen/string},
   :text
   {:zen/desc "Text representation of the full name",
    :confirms #{string},
    :type zen/string},
   :family
   {:zen/desc "Family name (often called 'Surname')",
    :confirms #{string},
    :type zen/string},
   :given
   {:type zen/vector,
    :zen/desc
    "Given names (not always 'first'). Includes middle names",
    :every {:confirms #{string}, :type zen/string}},
   :prefix
   {:type zen/vector,
    :zen/desc "Parts that come before the name",
    :every {:confirms #{string}, :type zen/string}},
   :suffix
   {:type zen/vector,
    :zen/desc "Parts that come after the name",
    :every {:confirms #{string}, :type zen/string}},
   :period
   {:zen/desc "Time period when name was/is in use",
    :confirms #{Period}}},
  :confirms #{Element}},
 Duration
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys {},
  :confirms #{Quantity}},
 Timing
 {:zen/tags #{fhir/complex-type zen/schema},
  :type zen/map,
  :keys
  {:event
   {:type zen/vector,
    :zen/desc "When the event occurs",
    :every {:confirms #{dateTime}, :type zen/datetime}},
   :repeat
   {:zen/desc "When the event is to occur",
    :confirms #{Element},
    :keys
    {:frequencyMax
     {:zen/desc "Event occurs up to frequencyMax times per period",
      :confirms #{positiveInt}},
     :when
     {:type zen/vector,
      :zen/desc "Code for time period of occurrence",
      :every
      {:confirms #{code},
       :valueset {:name fhir.valuesets/event-timing},
       :type zen/string}},
     :offset
     {:zen/desc "Minutes from event (before or after)",
      :confirms #{unsignedInt}},
     :periodUnit
     {:zen/desc "s | min | h | d | wk | mo | a - unit of time (UCUM)",
      :confirms #{code},
      :valueset {:name fhir.valuesets/units-of-time},
      :type zen/string},
     :frequency
     {:zen/desc "Event occurs frequency times per period",
      :confirms #{positiveInt}},
     :durationMax
     {:zen/desc "How long when it happens (Max)",
      :confirms #{decimal}},
     :duration
     {:zen/desc "How long when it happens", :confirms #{decimal}},
     :bounds
     {:zen/desc
      "Length/Range of lengths, or (Start and/or end) limits",
      :confirms #{Range Period Duration}},
     :durationUnit
     {:zen/desc "s | min | h | d | wk | mo | a - unit of time (UCUM)",
      :confirms #{code},
      :valueset {:name fhir.valuesets/units-of-time},
      :type zen/string},
     :dayOfWeek
     {:type zen/vector,
      :zen/desc "mon | tue | wed | thu | fri | sat | sun",
      :every
      {:confirms #{code},
       :valueset {:name fhir.valuesets/days-of-week},
       :type zen/string}},
     :count
     {:zen/desc "Number of times to repeat", :confirms #{positiveInt}},
     :periodMax
     {:zen/desc "Upper limit of period (3-4 hours)",
      :confirms #{decimal}},
     :period
     {:zen/desc "Event occurs frequency times per period",
      :confirms #{decimal}},
     :countMax
     {:zen/desc "Maximum number of times to repeat",
      :confirms #{positiveInt}},
     :timeOfDay
     {:type zen/vector,
      :zen/desc "Time of day for action",
      :every {:confirms #{time}}}}},
   :code
   {:zen/desc "BID | TID | QID | AM | PM | QD | QOD | +",
    :confirms #{CodeableConcept}}},
  :confirms #{BackboneElement}}}
